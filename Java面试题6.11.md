### 了解Java注解的原理吗，注解如何获取？

- 注解相当于一种标记，在程序中加了注解等于为程序打上了某种标记。程序可以利用Java的反射机制来了解你的类以及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加载包，类，字段，方法，方法的参数以及局部变量上

### String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？

- String是不可变的(修改String时，不会再原有的内存地址上修改，而是重新指向一个新对象)，String用final修饰的，不可继承，String本质上是final的char[]数组，所以char[]数组的内存地址不会被修改，而且String也没有对外暴露修改char[]数组的方法。不可变性可以保证线程安全以及字符串常量池的实现
- StringBuffer是线程安全的
- StringBuilder是非线程安全的

### Java里的幂等性了解吗？

- 幂等性原本是数学上的一个概念，即：f(x)=f(f(x)),对同一个系统，使用童颜高德条件，一次请求和重复的多次请求对系统资源的影响是一致的
- 幂等性最为常见的应用就是电商的客户付款，试想下，如果你在付款的时候因为网络等各种问题失败了，然后又去重复的付了一次，是一种糟糕的体验。幂等性就是为了解决这样的问题

#### 实现幂等性可以使用Token机制
- 核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一个执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。

### Java泛型了解吗，知道它的运行机制吗？

- 泛型是为了参数化类型

#### 为什么使用泛型？

- 1、相对于使用Object这种简单粗暴的方式，泛型提供了一种参数化的能力，使得数据的类型可以像参数一样被传递进来，这样提供了一种扩展能力
- 2、当数据类型确定以后，提供了一种类型检测机制，只有相匹配的数据才可以正常赋值，否则编译错误，增强了安全性
- 3、泛型提高了代码的可读性，不必等到运行时采取执行类型转换，在编写代码阶段程序员就可以通过参数书写正确的数据类型

#### 除了用表示泛型外，还有<?> 这种形式 ？被称为通配符

- 被称作无限定的通配符
- 被称作有上限的通配符
- 被称作有下线的通配符

### Java里的反射为何会消耗性能？

### Java的类型擦除，知道它的原理吗？

- 泛型信息只存在代码编译阶段，在进入JVM之前，与泛型相关的信息都会被擦除掉
- 在类型擦除的时候，如果泛型类里的类型参数没有指定上限，则会被转成Object类型；如果指定了上限，则会被转换成对应的类型上限

### 闭包了解吗，Java里有闭包吗？

- 函数和函数内部能访问到的变量的总和，就是一个闭包
```
fun main(args: Array<String>) {
    test
}
val test = if (5 > 3) {
    print("yes")
} else {
    print("no")
}
```

### Lambda表达式了解吗？

- Lam表达表达式俗称匿名函数。Kotlin的Lambda表达式更“纯粹”一点，因为它是真正把Lambda抽象为一种类型，而Java 8 的Lambda只是但方法匿名接口实现的语法糖
```
val printMsg = { msg: String -> 
	println(msg) 
}

fun main(args: Array<String>) {
  printMsg("hello")
}
```

### 高阶函数了解吗？

- 当定义一个闭包作为参数的函数，称这个函数为高阶函数

```
fun main(args: Array<String>) {
    log("world", printMsg)
}

val printMsg = { str: String ->
    println(str)
}

val log = { str: String, printLog: (String) -> Unit ->
    printLog(str)
}
```
