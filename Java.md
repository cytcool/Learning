## Java面向对象
### 继承的实现

1、继承的基本概念
    
- 扩展父类的功能

2、Java中使用extends关键字完成继承

- class 子类 extends 父类

### 继承的限制

1、在Java中只允许单继承，但可以多层继承


```
class People{
}

class Worker extends People{
}

class PetWorker extends Worker{
}

```


2、子类不能**直接访问**父类的私有成员

（只能通过get和set方法才能访问）

3、**public**和**protected** 都可以用作于子类，但静态类不能被子类继承和覆盖。

4、类变量可以通过类直接调用

5、子类方法的权限至少要大于父类方法的权限

### 构造方法的实例化过程

#### 子类对象的实例化

1、在子类对象实例化之前，必须先调用父类中的构造方法，之后调用子类构造方法

（没有父亲哪来的儿子！）

### 方法的重写

1、在继承中，也存在着重写的概念，其实就是子类定义了和父类同名的方法

2、定义：

- 方法名称相同，返回值类型相同，参数相同

3、重写限制：

- 被子类重写的方法不能拥有比父类方法更加严格的访问权限

4、访问权限：

- private<default<public

### 方法的重载

- 参数表必须不同（参数个数不同or参数类型不同or参数个数与类型都不同）与返回值无关

### Super关键字

- 强行调用父类方法的执行
- super不一定在重写中使用，也可以表示哪些方法时从父类中继承而来的

```
class A{
    public void tell(){
        System.out.println("我是tell方法");
        
    }
}
class B extends A{
    public void tell(){
        super.tell();
        System.out.println("我重写了tell方法");
    }
}

```

### final关键字

1、final关键字在java中被称为完结器，表示最终的意思

2、final能声明类、方法、属性：
- 使用final声明的类不能被继承
- 使用final声明的方法不能被重写
- 使用final声明的变量变成常量，常量是不可以被修改的
- 使用final声明的变量名全用大写字母


### 抽象类

1、概念
- 包含一个抽象方法的类就是抽象类

2、抽象方法：
- 声明而未被实现的方法，抽象方法必须使用abstract关键字声明

3、抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法

4、定义格式：

```
abstract class className{
    属性
    方法
    抽象方法
}
```
5、抽象类不能直接实例化，要通过其子类进行实例化

6、abstract类不能用来创建abstract类的对象

#### 抽象类的应用




### 接口

1、接口是Java中最重要的概念，接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成

2、接口的格式：
```
interface interfaceName{
    全局常量
    抽象方法
}
```

3、接口的实现必须通过子类，使用关键字implements，而且接口是可以多实现的。（弥补类单继承的缺陷）

4、一个子类可以同时继承抽象类和实现接口

5、一个接口不能继承一个抽象类，但是却可以通过extends关键字同时继承多个接口，实现接口的多继承

6、接口中声明的“**变量**”必须为public final static,或者final 所以为常量;接口有函数声明和变量声明。函数没有函数体





### 多态性

1、多态性的体现：
- 方法的重载和重写
- 对象的多态性

2、对象的多态性：
- 向上转型：程序会自动完成

父类 父类对象 = 子类实例

- 向下转型：强制类型转换

子类 子类对象 = （子类）父类实例

### instanceof关键字

- 在Java中可以使用instanceof关键字判断一个对象到底是不是一个类的实例
- instanceof关键字返回的是boolean类型


### 泛型

- 泛型可以解决数据类型的安全性问题
- 主要的原理是在类声明的时候通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型

##### 格式：

```
    访问权限 class 类名称<泛型，泛型……>{
    属性
    方法
    }
    
class Point<T>{
}
```

##### 对象的创建：

类名称<具体类型> 对象名称 = new 类名称<具体类型>();

Point<String> p = new Point<String>();

##### 设置多个泛型

- 设置多个泛型直接在<>中添加多个泛型就可以了

### 通配符    <?>

### 泛型接口

- 格式
    interface 接口名称<泛型标识>{}

### 泛型方法

- 泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据类型


```
class Gener{
    public <T>T tell(T t){
        return t;
    }
}
```

### 泛型数组

- 在使用泛型方法的时候，也可以传递或返回一个泛型数组


### 判断一个浮点数是否等于零

- 对于计算机中32bit表示的浮点数，表示的术的绝对值的范围约为(1e-38)~(1e+38)，即2^(-127)~1.11111111B*(2^128),浮点数的绝对值再怎么小，也不可能小过2^(-127),浮点数中不存在绝对0，所以我们只能取近似值。 
- 要判断一个双精度浮点数：if( abs(f) <= 1e-15 )


# Java集合

## Collection接口

### Collection子接口

#### List接口 List<E>

1、List接口可以存放任意的数据，而且在List接口中内容是可以重复的

2、List接口常用子类：
- ArrayList
- Vector

3、常用操作：
- 判断集合是否为空：boolean isEmpty() 返回true或者flase
- 查找指定的对象是否存在:int indexOf(Object o) 返回指定元素的索引

##### ArrayList

- 采用异步处理方式，性能高
- 属于非线程安全

##### Vector

- 采用同步处理方式，性能低
- 属于线程安全


#### Set接口 Set<E>

1、Set接口中不能加入重复元素，但是可以排序

2、Set接口常用子类：
- 散列存放：HashSet
- 有序存放：TreeSet

#### Iterator接口

1、集合输出的标准操作

标准做法，使用Iterator接口

2、操作原理：

Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断是否有内容，如果有内容则把内容取出

##### 初始化

List<String> lists = new ArrayList<String>();

Iterator<String> iter = lists.iterator();

#### Map接口 Map<Key,Value>

1、保存形式：

key->value的方式保存

例：小雪：15806880888

2、常用子类：

- HashMap：无序存放，key不允许重复
- Hashtable：无序存放，key不允许重复


##### PS：我们在程序中经常使用“System.out.println()”来输出信息，System是java.lang包下的一个类，out为System的final静态成员（PrintStream类型），println()是PrintStream类的实例方法。

### JAVA多线程

#### 线程与进程

##### 线程
- 程序中单独顺序的控制流
- 线程本身依靠程序进行运行
- 线程是程序中的顺序控制流，只能使用分配给程序的资源和环境

##### 进程
- 执行中的程序
- 一个进程可以包含一个或多个进程
- 一个进程至少包含一个线程

##### 单线程
- 程序中只存在一个线程，实际上主方法就是一个主线程

##### 多线程

- 多线程是在一个程序中运行多个任务
- 多线程的目的是更好的使用CPU资源

#### 线程的实现

- 在Java中，线程的实现有两种方法：

1、继承Thread类 2、实现Runnable接口

- 线程的启动是通过start();
- 并发进行的

##### Thread类

- Thread类是在java.lang包中定义的，继承Thread类必须重写run（）方法

```
class className extends Thread{
    run(){};
}
```
##### Runnable接口

- 实现Runnable接口也必须重写run()方法
- 通过创建Thread类来启动Runnable接口

#### 线程的状态

- 创建状态：准备好了一个多线程的对象
- 就绪状态：调用了start()方法，等待CPU进行调度
- 运行状态：执行run()方法
- 阻塞状态：暂时停止执行，可能将资源交给其他线程使用
- 终止状态(死亡状态)：线程销毁

#### 线程的常用方法

1、取得线程名称

getName()

2、取得当前线程对象

currentThread()

3、判断线程是否启动

isAlive()

4、线程的强行运行()

join()

5、线程的休眠

sleep()

#### 线程的优先级

1、优先级顺序设置

- 1- MIN_PRIORITY
- 10- MAX_PRIORITY
- 5- NORM_PRIORITY
- 如果什么都不设置默认值是5

#### 线程同步

- 解决资源共享问题

1、同步代码块

- 在代码块上加上"synchronized"关键字，则此代码块就称为同步代码块

2、格式：
```
    synchronized(同步对象){
        需要同步的代码块
    }
```

3、同步方法

- 除了代码块可以同步，方法也可以同步

4、方法同步格式：
- synchronized void 方法名称(){}

## Java IO简介

- IO体系的基本功能就是：读和写

### IO流

- 作用：读写设备上的数据，硬盘文件、内存、键盘、网络……
- 根据数据的走向，可分为：输入流、输出流
- 根据处理的数据类型，可分为：字节流、字符流

#### 字节流与字符流

- 字节流可以处理所有类型的数据，如MP3、图片、文字、视频等，读到一个字节就返回一个字节(在Java中对应的类都以“Stream”结尾)
- 字符流仅能处理纯文本数据，如txt文本等。在读取时，读到一个或者多个字节，先查找指定的编码表，然后将查到的字符返回(在Java中对应的类都以“Reader”或“Writer”结尾)



