### Android有哪几种进程，是如何管理的？

#### 前台进程

##### 用户当前操作所必须的进程，如果一个进程满足以下任一条件，即视为前台进程：

- 托管用户正在交互的Activity(已调用Activity的onResume()方法)
- 托管某个Service，后者绑定到用户正在交互的Activity
- 托管正在“前台”运行的Service(服务已调用startForeground())
- 托管正执行一个生命周期的Service(onCreate()、onStart()、或onDestory())
- 托管正执行其onReceive()方法的BroadcastReceiver

##### 通过，在任意给定时间前台进程都为数不多，只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应

#### 可见进程

##### 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任意条件，即视为可见进程：

- 托管不在前台、但仍对用户可见的Activity(已调用onPause()方法)，例如，如果前台Activity启动了一个对话框，允许在其后显示上一个Activity，则可能会发生这种情况
- 托管绑定到可见(或前台)Activity的Service

#### 服务进程

- 正在运行已使用startService()方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常会执行一些用户关心的操作(例如，在后台播放音乐或从网络下载数据)。因此，除非内存不足以维持所有前台进程和可见进程同时进行，否则系统会让服务进程保持运行状态

#### 后台进程

- 包含目前对用户不可见的Activity的进程(已调用Activity的onStop()方法)。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。
- 通常会有很多后台进程在运行，因此它们会保存在LRU(最近最少使用)列表中，以确保包含用户最近查看的Activity的进程最后一个呗终止
- 如果某个Activity正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该Activity时，Activity会恢复期所有可见状态

#### 空进程

- 不含任何活动应用组件的进程
- 保留这种进程的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间
- 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程
- ActivityManagerService负责根据各种策略算法计算进程的adj值，然后交由系统内核进行进程的管理

### SharePreference性能优化，可以做进程同步吗？

- 在Android中，SharePreference是一个轻量级的存储类，特别适合用于保存软件配置参数。
- 使用SharePreference保存数据，其背后是用xml文件存放数据的

#### 之所以说SharePreference是一种轻量级的存储方式，是因为它在加载的时候会把整个文件全部加载进内存，如果SharePreference文件比较大，会带来以下问题：

- 第一次从sp中获取值得时候，有可能阻塞主线程，使界面卡顿、掉帧
- 解析sp的时候回产生大量的临时对象，导致频繁GC，引起界面卡顿
- 这些key和value会永远存在内存之中，占用大量内存

#### 如何优化

- 不要存放大的key和value，会引起界面卡顿、频繁GC、占用内存等
- 毫不相关的配置项不要放在一起，文件越大读取越慢
- 读取频发的key和不易变动的key尽量不要放在一起，影响速度
- 不要乱edit和apply，尽量批量修改一次提交，多次apply会阻塞主线程
- 尽量不要存放JSON和HTML，这种场景请直接使用JSON
- SharePreference无法进行跨进程通信，MODE_MULTI_PROCESS只是保证了在API11以前的系统上，如果sp已经被读取金内存，再次获取这个SharePreference的时候，如果有这个flag，会重新读一遍文件而已

### 如何做SQLite升级？

#### 数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：

- 1、将现有表命名为临时表
- 2、创建新表
- 3、将临时表的数据导入新表
- 4、删除新表

### 进程保活如何做，如何唤醒其他进程？

- 1、提升进程的优先级，降低进程被杀死的概率
- 2、拉活已经被杀死得劲进程

#### 如何提升优先级

- 监控手机锁屏事件，在屏幕锁屏时启动一个像素的Activity，在用户解锁时将Activity销毁掉，前台Activity可以将进程编程前台进程，优先级升级到最高

#### 拉活

- 利用广播拉活Activity

### 理解序列化吗？Android为什么引入Parcelable？

#### 所谓序列化就是将对象编程二进制流，便于存储和传输

- Serializable是java实现的一套序列化方式，可能会触发频发的IO操作，效率比较低，适合将对象存储到磁盘上的情况
- Parcelable是Android提供一套序列化机制，它将序列化的字节流写入到一个共享内存中，其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息