## Android进程保活

- 提供进程优先级，降低进程被杀死的概率
- 在进程被杀死后，进行拉活

### 进程的优先级

- Android系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存
- 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中
- 必要时，系统会首先消除重要性最低的进程，然后是清除重要性稍低一级的进程，依次类推，以回收系统资源

#### 进程的优先级，划分5级：

- 1、前台进程
- 2、可见进程
- 3、服务进程
- 4、后台进程
- 5、空进程

#### 前台进程

- 用户当前操作所必须的进程。通常在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们

##### 属于前台进程的

- 拥有用户正在交互的Activity(已调用onResume())
- 拥有某个Service，后者绑定到用户正在交互的Activity
- 拥有正在“前台”运行的Service(服务已调用startForeground())
- 拥有正执行一个生命周期的Service(onCreate()、onStart()或onDestroy())
- 拥有正执行其onReceive()方法的BroadcastReceiver

#### 可见进程

- 没有任何前台组件，但仍会影响用户在屏幕上所见内容的进程
- 可见进程被称为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程

##### 属于可见进程

- 拥有不在前台、但仍对用户可见的Activity(已调用onPause())
- 拥有绑定到可见(或前台)Activity的Service

#### 服务进程

- 尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作(例如，在后台播放音乐或从网络下载数据)
- 因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态

##### 属于服务进程的

- 正在运行startService()方法启动的服务，且不属于上述两个更高类别进程的进程

#### 后台进程

- 后台进程对用户体验没有直接影响，系统可能随时会终止它们，以回收内存供前台进程、可见进程或服务进程使用
- 通常会有很多后台进程在运行，因此它们会保存在LRU列表中，以确保包含用户最近查看的Activity的进程最后一个呗终止
- 如果某个Activity正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户返回该Activity时，Activity会恢复其所有可见状态

##### 属于后台进程的

- 对用户不可见的Activity的进程(已调用Activity的onStop()方法)

#### 空进程

- 保留这种进程的唯一目的是用作缓存，以缩短下次再其中运行组件所需的启动时间
- 为使总体系统资源在进程缓存和底层内核之间保持平衡，系统往往会终止这些进程

##### 属于空进程的

- 不含任何活动应用组件的进程

### Android进程回收策略

- Android中对于内存的回收，主要依靠LowMemoryKiller来完成，是一种根据OOM_ADJ阈值级别触发相应力度的内存回收的机制
- 一般来说，OOM_ADJ为0代表的是前台进程，大于0的表示一些后台进程或者是服务进程。而OOM_ADJ小于0表示非Android进程(纯Linux进程)
- 在Lowmemorykiller回收内存时会根据进程的级别优先杀死OOM_ADJ比较大的进程，而对于优先级相同的进程则优先杀死那些占用内存和存活时间比较大的进程。
- 综上所述，为了减少进程被杀的概率，则要想办法提高进程的优先级

### 提升进程优先级的方案

#### 利用Activity提升权限

- 监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的Activity，在用户解锁时将Activity销毁掉，该Activity需设计成用户无感知的
- 通过上述方法，可以使进程的优先级在屏幕锁屏时由4提升为最高优先级1

#### 利用Notification提升权限

- 在Android中Service的优先级为4，通过setForeground接口可以将后台Service设置为前台Service，使进程的优先级由4提升为2，从而使进程的优先级仅仅低于用户当前正在交互的进程，与可见进程优先级一致，使进程被杀死的概率大大降低
- 如何实现：通过实现一个内部Service，在LiveService和其内部Service中同时发送具有相同ID的Notification，然后将内部Service结束掉。随着内部Service的结束，Notification将会消失，但系统优先级依然保持为2

### 进程死后拉活

#### 利用系统广播拉活

- 在发生特定系统事件时，系统会发出相应的广播，通过在AndroidManifest中静态注册对应的广播监听器，即可在发生响应事件时拉活

#### 缺点：

- 1、广播接收器被管理软件、系统软件通过自启管理等功能禁用的场景无法接收到广播，从而无法自启
- 2、系统广播事件不可控，只能保证发生事件时拉活进程，但无法保证进程挂掉后立即拉活

#### 利用第三方应用广播拉活

#### 利用系统Service机制拉活

- 将Service设置为START_STICKY，利用系统机制在Service挂掉后自动拉活

#### 有两种情况下无法拉活

- 1、Service第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内Service被杀死达到5次，则系统不会再拉起
- 2、进程被取得Root权限的管理工具或系统工具通过forestop停止掉，无法启动

#### 利用Native进程拉活

- 主要思想：利用Linux中的fork机制创建Native进程，在Native进程中监控主进程的存活，当进程挂掉后，在Native进程中立即对主进程进行拉活
- 主要原理：在Android中所有进程和系统组件的生命周期都受ActivityManagerService的同一管理。而且通过Linux的fork机制创建的进程为纯Linux进程，其生命周期不受Android的管理

##### 要在Native进程中感知主进程是否存活有两种实现方式：

- 1、在Native进程中通过死循环或定时器，轮询判断主进程是否存活，当主进程不存活时进行拉活。该方案的很大缺点是不停的轮询执行判断逻辑，非常耗电
- 2、在主进程中创建一个监控文件，并且在主进程中持有文件锁，在拉活进程启动后申请文件锁将会被阻塞，一旦可以成功获取到锁，说明主进程挂掉，即可进行拉活，由于Android中的应用都运行于虚拟机上，Java层的文件锁与Linux层的文件锁是不同的，要实现该功能需要封装Linux层的文件锁供上层调

#### 利用JobScheduler机制拉活

- Android5.0以后系统对Native进程等加强了管理，Native拉活方式失效，系统在Android5.0以上版本提供了JobScheduler接口，系统会定时调用该进程以使应用进行一些逻辑操作